# 🔍 財政部 CSV 欄位對應修正指南

**問題**：解析到 0 張發票，欄位識別失敗  
**時間**：2025-08-04 11:06  
**原因**：CSV 欄位結構與預期不符

---

## 🚨 問題診斷

### 當前狀況
```json
{
  "message": "✅ 成功解析 0 張發票",
  "message": "📋 解析到 0 張發票"
}
```

### 可能原因
1. **欄位名稱不匹配**：CSV 標題與我們的識別邏輯不符
2. **分隔符問題**：可能不是逗號分隔
3. **編碼問題**：中文欄位名稱亂碼
4. **資料格式問題**：金額或日期格式異常

---

## 🔧 立即診斷步驟

### 步驟 1：檢查 CSV 實際結構
```javascript
// 執行詳細的 CSV 結構分析
debugCsvStructureDetailed()
```

### 步驟 2：手動檢查欄位映射
```javascript
// 檢查欄位識別結果
checkFieldMapping()
```

### 步驟 3：測試資料提取
```javascript
// 測試單行資料提取
testSingleRowExtraction()
```

---

## 🛠️ 修正工具

讓我建立一個詳細的診斷工具：

```javascript
/**
 * 🔍 詳細的 CSV 結構診斷
 */
function debugCsvStructureDetailed() {
  Logger.log('🔍 開始詳細 CSV 結構診斷...');
  
  try {
    const threads = GmailApp.search('from:einvoice@einvoice.nat.gov.tw subject:彙整', 0, 1);
    
    if (threads.length === 0) {
      Logger.log('❌ 找不到財政部郵件');
      return;
    }
    
    const message = threads[0].getMessages()[0];
    const attachments = message.getAttachments();
    
    for (let attachment of attachments) {
      const fileName = attachment.getName();
      
      if (fileName.toLowerCase().includes('.csv')) {
        Logger.log(`\n📊 詳細分析 CSV: ${fileName}`);
        
        // 嘗試多種編碼
        let csvContent = null;
        const encodings = ['UTF-8', 'Big5', 'GBK'];
        
        for (let encoding of encodings) {
          try {
            csvContent = attachment.getDataAsString(encoding);
            Logger.log(`✅ 成功使用 ${encoding} 編碼`);
            break;
          } catch (error) {
            Logger.log(`❌ ${encoding} 編碼失敗`);
          }
        }
        
        if (!csvContent) {
          Logger.log('❌ 所有編碼都失敗');
          return;
        }
        
        // 分析分隔符
        const firstLine = csvContent.split('\n')[0];
        Logger.log(`\n📋 第一行原始內容:`);
        Logger.log(`"${firstLine}"`);
        
        const separators = [',', ';', '\t', '|'];
        separators.forEach(sep => {
          const columns = firstLine.split(sep);
          Logger.log(`\n分隔符 "${sep}": ${columns.length} 個欄位`);
          columns.forEach((col, index) => {
            Logger.log(`  欄位 ${index + 1}: "${col.trim()}"`);
          });
        });
        
        // 分析前 5 行資料
        const lines = csvContent.split('\n');
        Logger.log(`\n📊 前 5 行詳細分析:`);
        
        for (let i = 0; i < Math.min(5, lines.length); i++) {
          const line = lines[i].trim();
          if (line) {
            Logger.log(`\n行 ${i + 1}:`);
            Logger.log(`原始: "${line}"`);
            
            const columns = line.split(',');
            Logger.log(`欄位數: ${columns.length}`);
            
            columns.forEach((col, colIndex) => {
              const cleanCol = col.replace(/["\s]/g, '');
              Logger.log(`  [${colIndex + 1}] "${col.trim()}" -> "${cleanCol}"`);
              
              // 檢查是否是數字
              const numValue = parseFloat(cleanCol);
              if (!isNaN(numValue) && numValue > 0) {
                Logger.log(`    -> 數值: ${numValue}`);
              }
            });
          }
        }
      }
    }
    
  } catch (error) {
    Logger.log(`❌ 詳細診斷失敗: ${error.toString()}`);
  }
}

/**
 * 🎯 檢查欄位映射結果
 */
function checkFieldMapping() {
  Logger.log('🎯 檢查欄位映射結果...');
  
  try {
    const threads = GmailApp.search('from:einvoice@einvoice.nat.gov.tw subject:彙整', 0, 1);
    const message = threads[0].getMessages()[0];
    const attachments = message.getAttachments();
    
    for (let attachment of attachments) {
      const fileName = attachment.getName();
      
      if (fileName.toLowerCase().includes('.csv')) {
        const csvContent = attachment.getDataAsString('UTF-8');
        const lines = csvContent.split('\n');
        const headers = lines[0].split(',');
        
        Logger.log(`\n📋 CSV 標題行分析:`);
        Logger.log(`總欄位數: ${headers.length}`);
        
        headers.forEach((header, index) => {
          const cleanHeader = header.replace(/["\s]/g, '');
          Logger.log(`\n欄位 ${index + 1}: "${header.trim()}"`);
          Logger.log(`  清理後: "${cleanHeader}"`);
          Logger.log(`  小寫: "${cleanHeader.toLowerCase()}"`);
          
          // 檢查是否匹配我們的識別邏輯
          const matches = [];
          
          if (cleanHeader.toLowerCase().includes('日期') || 
              cleanHeader.toLowerCase().includes('date') || 
              cleanHeader.toLowerCase().includes('時間')) {
            matches.push('日期欄位');
          }
          
          if (cleanHeader.toLowerCase().includes('金額') || 
              cleanHeader.toLowerCase().includes('總計') || 
              cleanHeader.toLowerCase().includes('amount') || 
              cleanHeader.toLowerCase().includes('price')) {
            matches.push('金額欄位');
          }
          
          if (cleanHeader.toLowerCase().includes('商家') || 
              cleanHeader.toLowerCase().includes('店家') || 
              cleanHeader.toLowerCase().includes('賣方') || 
              cleanHeader.toLowerCase().includes('merchant')) {
            matches.push('商家欄位');
          }
          
          if (cleanHeader.toLowerCase().includes('發票') || 
              cleanHeader.toLowerCase().includes('號碼') || 
              cleanHeader.toLowerCase().includes('invoice') || 
              cleanHeader.toLowerCase().includes('number')) {
            matches.push('發票號碼欄位');
          }
          
          if (matches.length > 0) {
            Logger.log(`  🎯 識別為: ${matches.join(', ')}`);
          } else {
            Logger.log(`  ❓ 未識別`);
          }
        });
        
        // 測試第二行資料
        if (lines.length > 1) {
          Logger.log(`\n📊 第二行資料測試:`);
          const dataRow = lines[1].split(',');
          
          dataRow.forEach((cell, index) => {
            const cleanCell = cell.replace(/["\s]/g, '');
            Logger.log(`  [${index + 1}] "${cell.trim()}" -> "${cleanCell}"`);
            
            const numValue = parseFloat(cleanCell);
            if (!isNaN(numValue) && numValue > 0) {
              if (numValue >= 1 && numValue <= 100000) {
                Logger.log(`    -> 可能是金額: ${numValue}`);
              } else {
                Logger.log(`    -> 數值過大，可能是ID: ${numValue}`);
              }
            }
          });
        }
      }
    }
    
  } catch (error) {
    Logger.log(`❌ 欄位映射檢查失敗: ${error.toString()}`);
  }
}

/**
 * 🧪 測試單行資料提取
 */
function testSingleRowExtraction() {
  Logger.log('🧪 測試單行資料提取...');
  
  try {
    const threads = GmailApp.search('from:einvoice@einvoice.nat.gov.tw subject:彙整', 0, 1);
    const message = threads[0].getMessages()[0];
    const attachments = message.getAttachments();
    
    for (let attachment of attachments) {
      const fileName = attachment.getName();
      
      if (fileName.toLowerCase().includes('.csv')) {
        const csvContent = attachment.getDataAsString('UTF-8');
        const lines = csvContent.split('\n');
        
        if (lines.length > 1) {
          Logger.log(`\n🧪 測試第二行資料提取:`);
          
          const headers = lines[0].split(',');
          const dataRow = lines[1].split(',');
          
          Logger.log(`標題行: ${headers.length} 個欄位`);
          Logger.log(`資料行: ${dataRow.length} 個欄位`);
          
          // 嘗試手動提取
          let extractedData = {
            date: '',
            amount: 0,
            merchant: '',
            invoiceNumber: ''
          };
          
          // 逐欄位分析
          for (let i = 0; i < Math.min(headers.length, dataRow.length); i++) {
            const header = headers[i].replace(/["\s]/g, '').toLowerCase();
            const data = dataRow[i].replace(/["\s]/g, '');
            
            Logger.log(`\n欄位 ${i + 1}:`);
            Logger.log(`  標題: "${headers[i].trim()}"`);
            Logger.log(`  資料: "${dataRow[i].trim()}"`);
            
            // 嘗試識別和提取
            if (header.includes('日期') || header.includes('date')) {
              extractedData.date = data;
              Logger.log(`  -> 識別為日期: ${data}`);
            }
            
            const numValue = parseFloat(data);
            if (!isNaN(numValue) && numValue >= 1 && numValue <= 100000) {
              if (extractedData.amount === 0 || numValue > extractedData.amount) {
                extractedData.amount = numValue;
                Logger.log(`  -> 識別為金額: ${numValue}`);
              }
            }
            
            if (header.includes('商家') || header.includes('店家') || header.includes('merchant')) {
              extractedData.merchant = data;
              Logger.log(`  -> 識別為商家: ${data}`);
            }
            
            if (header.includes('發票') || header.includes('invoice')) {
              extractedData.invoiceNumber = data;
              Logger.log(`  -> 識別為發票號碼: ${data}`);
            }
          }
          
          Logger.log(`\n📊 提取結果:`);
          Logger.log(`  日期: "${extractedData.date}"`);
          Logger.log(`  金額: ${extractedData.amount}`);
          Logger.log(`  商家: "${extractedData.merchant}"`);
          Logger.log(`  發票號碼: "${extractedData.invoiceNumber}"`);
          
          if (extractedData.amount > 0) {
            Logger.log(`✅ 成功提取到有效資料！`);
          } else {
            Logger.log(`❌ 未能提取到有效金額`);
          }
        }
      }
    }
    
  } catch (error) {
    Logger.log(`❌ 單行提取測試失敗: ${error.toString()}`);
  }
}
```

---

## 🚀 執行診斷

請按順序執行以下函數：

```javascript
// 1. 詳細結構診斷
debugCsvStructureDetailed()

// 2. 檢查欄位映射
checkFieldMapping()

// 3. 測試單行提取
testSingleRowExtraction()
```

---

## 📊 預期結果

診斷完成後，我們會看到：
- 📋 CSV 的實際欄位名稱
- 🎯 哪些欄位被正確識別
- 💰 金額資料在哪個欄位
- 📅 日期格式是什麼樣的
- 🏪 商家資訊的位置

根據診斷結果，我們就能修正欄位識別邏輯，讓每張發票都能正確解析！

---

**診斷指南建立時間**：2025-08-04 11:10  
**目標**：找出 CSV 欄位結構，修正解析邏輯